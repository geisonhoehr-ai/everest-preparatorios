# üö® PROBLEMA CR√çTICO: SESS√ÉO N√ÉO PERSISTENTE - EVEREST PREPARAT√ìRIOS

## üìã **RESUMO DO PROBLEMA:**

O middleware est√° mostrando "Sess√£o: false" em todas as rotas, mesmo quando o usu√°rio est√° logado. Isso est√° causando:
- Menu admin n√£o aparecendo para professores
- Perfil n√£o persistente entre navega√ß√µes
- Erro de cookie: "Failed to parse cookie string"

## üîç **EVID√äNCIAS DOS LOGS:**

```
üîç [MIDDLEWARE] Rota: /membros Sess√£o: false
Failed to parse cookie string: SyntaxError: Unexpected token 'b', "base64-eyJ"... is not valid JSON
```

## ‚úÖ **TESTE PROGRAM√ÅTICO FUNCIONA:**

```
üß™ [TEST_PERSISTENT] Testando perfil persistente...
üîê [TEST_PERSISTENT] Fazendo login...
‚úÖ [TEST_PERSISTENT] Login bem-sucedido!
üë§ [TEST_PERSISTENT] Usu√°rio: professor@teste.com
üîë [TEST_PERSISTENT] Sess√£o ativa: true
‚úÖ [TEST_PERSISTENT] Role: teacher
üîÑ [TEST_PERSISTENT] Simulando persist√™ncia...
üîë [TEST_PERSISTENT] Sess√£o persistente: true
‚úÖ [TEST_PERSISTENT] Sess√£o mantida!
```

## üö® **PROBLEMA NO FRONTEND:**

- Sess√£o sempre false no middleware
- Menu admin n√£o aparece para professores
- Perfil mostra "Estudante" para professores

## üìÅ **ARQUIVOS AFETADOS:**

### **1. middleware.ts (ATUAL - COM PROBLEMA):**

```typescript
import { createMiddlewareClient } from '@supabase/auth-helpers-nextjs'
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export async function middleware(req: NextRequest) {
  const res = NextResponse.next()
  const supabase = createMiddlewareClient({ req, res })

  // Verificar sess√£o
  const { data: { session } } = await supabase.auth.getSession()
  
  console.log('üîç [MIDDLEWARE] Rota:', req.nextUrl.pathname, 'Sess√£o:', !!session)

  // Rotas p√∫blicas (permitir acesso sem login)
  const publicRoutes = [
    '/login-simple', 
    '/signup-simple', 
    '/', 
    '/test-session',
    '/dashboard',
    '/cursos',
    '/flashcards',
    '/quiz',
    '/provas',
    '/livros',
    '/redacao',
    '/membros',
    '/turmas',
    '/community',
    '/calendario',
    '/suporte'
  ]
  const isPublicRoute = publicRoutes.some(route => req.nextUrl.pathname.startsWith(route))

  // Permitir acesso a todas as rotas (n√£o for√ßar login)
  console.log('‚úÖ [MIDDLEWARE] Acesso permitido')
  return res
}

export const config = {
  matcher: [
    '/((?!api|_next/static|_next/image|favicon.ico).*)',
  ],
}
```

### **2. lib/auth-simple.ts (ATUAL):**

```typescript
'use client'

import { createClient } from '@/lib/supabase/client'
import { useState, useEffect } from 'react'

// Tipos simples
export interface AuthUser {
  id: string
  email: string
  role: 'student' | 'teacher' | 'admin'
}

export interface AuthState {
  user: AuthUser | null
  isLoading: boolean
  isAuthenticated: boolean
}

// Hook MUITO SIMPLES
export function useAuth() {
  const [authState, setAuthState] = useState<AuthState>({
    user: null,
    isLoading: true,
    isAuthenticated: false
  })

  const supabase = createClient()

  useEffect(() => {
    console.log('üîß [AUTH] Iniciando verifica√ß√£o de sess√£o...')
    
    // Verificar sess√£o uma √∫nica vez
    const checkSession = async () => {
      try {
        const { data: { session }, error } = await supabase.auth.getSession()
        
        if (error) {
          console.error('‚ùå [AUTH] Erro:', error)
          setAuthState({
            user: null,
            isLoading: false,
            isAuthenticated: false
          })
          return
        }
        
        if (session?.user) {
          console.log('‚úÖ [AUTH] Sess√£o encontrada:', session.user.email)
          
          // Buscar role usando email (agora que corrigimos as tabelas)
          const { data: roleData, error: roleError } = await supabase
            .from('user_roles')
            .select('role')
            .eq('user_uuid', session.user.email)
            .single()

          if (roleError) {
            console.warn('‚ö†Ô∏è [AUTH] Erro ao buscar role:', roleError)
          }

          const user: AuthUser = {
            id: session.user.id,
            email: session.user.email || '',
            role: (roleData?.role as any) || 'student'
          }

          console.log('üë§ [AUTH] Usu√°rio carregado:', user)
          setAuthState({
            user,
            isLoading: false,
            isAuthenticated: true
          })
        } else {
          console.log('‚ùå [AUTH] Nenhuma sess√£o')
          setAuthState({
            user: null,
            isLoading: false,
            isAuthenticated: false
          })
        }
      } catch (error) {
        console.error('‚ùå [AUTH] Erro:', error)
        setAuthState({
          user: null,
          isLoading: false,
          isAuthenticated: false
        })
      }
    }

    checkSession()

    // Escutar mudan√ßas
    const { data: { subscription } } = supabase.auth.onAuthStateChange(
      async (event, session) => {
        console.log('üîÑ [AUTH] Evento:', event, session?.user?.email)
        
        if (event === 'SIGNED_IN' && session?.user) {
          const { data: roleData } = await supabase
            .from('user_roles')
            .select('role')
            .eq('user_uuid', session.user.email)
            .single()

          const user: AuthUser = {
            id: session.user.id,
            email: session.user.email || '',
            role: (roleData?.role as any) || 'student'
          }

          setAuthState({
            user,
            isLoading: false,
            isAuthenticated: true
          })
        } else if (event === 'SIGNED_OUT') {
          setAuthState({
            user: null,
            isLoading: false,
            isAuthenticated: false
          })
        }
      }
    )

    return () => subscription.unsubscribe()
  }, [])

  // Fun√ß√µes simples
  const signIn = async (email: string, password: string) => {
    try {
      console.log('üîê [AUTH] Login:', email)
      const { data, error } = await supabase.auth.signInWithPassword({
        email,
        password
      })

      if (error) throw error
      return { success: true }
    } catch (error: any) {
      console.error('‚ùå [AUTH] Erro login:', error)
      return { success: false, error: error.message }
    }
  }

  const signUp = async (email: string, password: string, role: 'student' | 'teacher' = 'student') => {
    try {
      console.log('üìù [AUTH] Signup:', email)
      const { data, error } = await supabase.auth.signUp({
        email,
        password
      })

      if (error) throw error

      if (data.user) {
        await supabase
          .from('user_roles')
          .insert({
            user_uuid: data.user.email,
            role
          })
      }

      return { success: true }
    } catch (error: any) {
      console.error('‚ùå [AUTH] Erro signup:', error)
      return { success: false, error: error.message }
    }
  }

  const signOut = async () => {
    try {
      console.log('üö™ [AUTH] Logout')
      const { error } = await supabase.auth.signOut()
      if (error) throw error
      return { success: true }
    } catch (error: any) {
      console.error('‚ùå [AUTH] Erro logout:', error)
      return { success: false, error: error.message }
    }
  }

  return {
    ...authState,
    signIn,
    signUp,
    signOut
  }
}
```

## üéØ **SOLU√á√ÉO PROPOSTA:**

### **Etapa 1: Corrigir .env.local**

```bash
# .env.local
NEXT_PUBLIC_SUPABASE_URL=sua_url_supabase
NEXT_PUBLIC_SUPABASE_ANON_KEY=sua_chave_anon_supabase
SUPABASE_JWT_SECRET=sua_chave_secreta_jwt_copiada_do_supabase # <--- Adicione/Corrija esta linha
```

### **Etapa 2: Corrigir middleware.ts**

```typescript
// middleware.ts
import { createMiddlewareClient } from '@supabase/auth-helpers-nextjs'
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export async function middleware(req: NextRequest) {
  const res = NextResponse.next()
  const supabase = createMiddlewareClient({ req, res })

  try {
    // Tenta obter a sess√£o do Supabase
    const { data: { session }, error } = await supabase.auth.getSession()

    console.log('üîç [MIDDLEWARE] Rota:', req.nextUrl.pathname, 'Sess√£o:', !!session)

    // Define as rotas p√∫blicas que n√£o exigem autentica√ß√£o
    const publicRoutes = [
      '/login-simple',
      '/signup-simple',
      '/', // A rota raiz pode ser p√∫blica
      '/test-session'
    ]

    // Verifica se a rota atual √© uma rota p√∫blica
    const isPublicRoute = publicRoutes.some(route =>
      // Garante que a rota seja exata ou um prefixo direto (ex: /login-simple/...)
      req.nextUrl.pathname === route || req.nextUrl.pathname.startsWith(`${route}/`)
    )

    // L√≥gica de Redirecionamento:

    // 1. Se N√ÉO houver sess√£o E a rota N√ÉO for p√∫blica, redireciona para o login.
    if (!session && !isPublicRoute) {
      const redirectUrl = new URL('/login-simple', req.url)
      return NextResponse.redirect(redirectUrl)
    }

    // 2. Se HOUVER sess√£o E a rota for uma p√°gina de login/cadastro, redireciona para o dashboard.
    // Isso impede que usu√°rios logados acessem novamente as p√°ginas de autentica√ß√£o.
    if (session && (req.nextUrl.pathname === '/login-simple' || req.nextUrl.pathname === '/signup-simple')) {
      const redirectUrl = new URL('/dashboard', req.url)
      return NextResponse.redirect(redirectUrl)
    }

    // Se nenhuma das condi√ß√µes acima for atendida, permite o acesso √† rota.
    return res

  } catch (error) {
    console.error('‚ùå [MIDDLEWARE] Erro ao processar sess√£o ou cookie:', error)
    // Em caso de erro (ex: cookie malformado), tratamos como se n√£o houvesse sess√£o v√°lida.
    // Redireciona para o login se a rota for protegida.
    const publicRoutes = [
      '/login-simple',
      '/signup-simple',
      '/',
      '/test-session'
    ]
    const isPublicRoute = publicRoutes.some(route =>
      req.nextUrl.pathname === route || req.nextUrl.pathname.startsWith(`${route}/`)
    )

    if (!isPublicRoute) {
      const redirectUrl = new URL('/login-simple', req.url)
      return NextResponse.redirect(redirectUrl)
    }
    return res // Permite acesso a rotas p√∫blicas mesmo com erro
  }
}

export const config = {
  matcher: [
    '/((?!api|_next/static|_next/image|favicon.ico).*)',
  ],
}
```

## üß™ **TESTE DA CORRE√á√ÉO:**

Ap√≥s implementar as duas etapas da solu√ß√£o:

1. **Verifique o erro de cookie**: O erro `Failed to parse cookie string` deve desaparecer dos logs
2. **Monitore o log de sess√£o**: O log `üîç [MIDDLEWARE] Rota: /membros Sess√£o: false` deve mudar para `üîç [MIDDLEWARE] Rota: /membros Sess√£o: true` quando um usu√°rio estiver logado
3. **Teste o comportamento do frontend**:
   - Menu Admin: Para usu√°rios com role de teacher ou admin, o menu administrativo deve agora aparecer corretamente
   - Perfil: O UserProfile deve exibir o role correto (ex: "Professor" ou "Administrador") em vez de "Estudante"
   - Persist√™ncia da Sess√£o: A sess√£o deve persistir entre as navega√ß√µes

## üéØ **RESULTADO ESPERADO:**

- ‚úÖ Middleware detectando sess√£o corretamente
- ‚úÖ Menu admin aparecendo para professores
- ‚úÖ Perfil persistente entre navega√ß√µes
- ‚úÖ Logs confirmando autentica√ß√£o

---

**üö® ESTE √â O PROBLEMA MAIS CR√çTICO QUE AFETA TODA A PLATAFORMA EVEREST PREPARAT√ìRIOS!** 